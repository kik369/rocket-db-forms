use chrono::NaiveDateTime;
use std::fmt::Debug;

pub fn serialise_data<T, E, I>(items: I, mut vector: Vec<T>) -> Vec<T>
where
    I: Iterator<Item = Result<T, E>>,
    E: Debug,
{
    for item in items {
        match item {
            Ok(item) => vector.push(item),
            Err(e) => println!(
                "Encountered error while serializing database items: {:?}",
                e
            ),
        }
    }
    vector
}

// parses from "2020-01-01T00:00:00" to "2020-01-01 00:00:00"
// "2020-01-01T00:00:00" is the format that the datepicker returns
// "2020-01-01 00:00:00" is the format generated by 'DATETIME DEFAULT CURRENT_TIMESTAMP' in sqlite
pub fn parse_date(date: &str) -> Result<String, ()> {
    let parsed_end_date = NaiveDateTime::parse_from_str(date, "%Y-%m-%dT%H:%M:%S")
        .expect("Failed to parse date string");
    Ok(parsed_end_date.format("%Y-%m-%d %H:%M:%S").to_string())
}
